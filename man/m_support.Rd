% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/general.methods.R
\name{m_support}
\alias{m_support}
\title{Support recovery of the first pair of canonical directions using Mai and Zhang (2017)}
\usage{
m_support(x, y)
}
\arguments{
\item{x}{A matrix with n rows and p columns;
corresponds to the first data matrix.}

\item{y}{A matrix with n rows and q columns; corresponds to the second data matrix.}
}
\value{
A list of two arrays
\itemize{
\item sup.x - An array with length p with binary entries. If the i-th element
            is 0, it means that i is not in the support of \eqn{\alpha}.
            Conversely, if the i-th element is 1, it means i is in the support
            of \eqn{\alpha}.
\item sup.y - An array with length p with binary entries. If the i-th element
            is 0, it means that i is not in the support of \eqn{\beta}.
            Conversely, if the i-th element is 1, it means i is in the support
            of \eqn{\beta}.
}
}
\description{
Suppose \eqn{\alpha} and \eqn{\beta} are the first pair of canonical covariates
corresponding to random vectors X and Y.
This function uses Mai and Zhang (2017)'s SCCA to estimate \eqn{\alpha} and
\eqn{\beta}, and outputs their supports as estimates of the supports of \eqn{\alpha}
and \eqn{\beta}. The code in the authors' website is used to implement the method.
This gives an initial estimator of the support, which can be refined 
by a cleaning step (see Laha and Mukherjee, 2020). The refined estimator
of the support is given by the function \code{\link{g_support}}.
}
\examples{
library(mvtnorm)
#Simulate  standard normal data matrix: first generate alpha and beta
p <- 500; q <- 200; al <- c(rep(1, 10), rep(0, 490));
be <- c(rep(0,150), rnorm(50,1))

#Normalize alpha and beta
al <- al/sqrt(sum(al^2))
 be <- be/sqrt(sum(be^2))
n <- 300; rho <- 0.5

 #Creating the  covariance matrix
Sigma_mat <- function(p,q,al,be, rho)
{
Sx <- diag(rep(1,p), p, p)
Sy <- diag(rep(1,q), q, q)
Sxy <- tcrossprod(crossprod(rho*Sx, outer(al, be)), Sy)
Syx <- t(Sxy)
rbind(cbind(Sx, Sxy), cbind(Syx, Sy))
}
truesigma <-  Sigma_mat(p,q,al,be, rho)

#Simulating the data
Z <- mvtnorm::rmvnorm(n, sigma = truesigma)
x <- Z[,1:p]
y <- Z[,(p+1):(p+q)]

#Support of beta
which(m_support(x,y)$sup.y==1)
}
\references{
Laha, N., Mukherjee, R. (2020) 
\emph{Support recovery of canonical correlation analysis}. Submitted.

Mai, Q., Zhang, X. (2019) \emph{An iterative penalized least squares 
approach to sparse canonical correlation analysis}, Biometrics, 75, 734-744.
}
\seealso{
\code{\link{g_support}}
}
\author{
\href{https://connects.catalyst.harvard.edu/Profiles/display/Person/184207}{Nilanjana Laha}
(maintainer), \email{nlaha@hsph.harvard.edu},
Rajarshi Mukherjee, \email{ram521@mail.harvard.edu}.
}
